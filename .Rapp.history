str(country.df)
country.df <- fortify(readOGR(file.path(path.ch, "ch-country.json"), country.layers[1]))
ch.communes + geom_polygon(data = country.df, fill = NA, color = "black", size = 2) + geom_polygon(data = lake.df, fill = "lightgrey", colour = "lightgrey")
ch.communes + geom_polygon(data = country.df, fill = NA, color = "black", size = 0.1) + geom_polygon(data = lake.df, fill = "lightgrey", colour = "lightgrey")
country.layers
ch.communes + geom_polygon(data = lake.df, fill = "lightgrey", colour = "lightgrey")
ch.communes + geom_polygon(data = country.df, fill = NA, color = "black", size = 0.1) + geom_polygon(data = lake.df, fill = "lightgrey", colour = "lightgrey")
library(swiMap)
?getPathShp
require(rgdal)#
require(rgeos)#
require(ggplot2)
path.ch <- getPathShp('CH')#
ch <- readOGR(path.ch, layer = 'municipalities-without-lakes')#
ch.df <- formatShp(ch)#
# plot swiss commune map#
ch.communes <- ggplot(ch.df, aes(x = long, y = lat, group = group)) + geom_polygon(size = 0.01, aes(fill = GEMNAME)) +#
theme_minimal() + theme(legend.position = "none", panel.grid = element_blank(), axis.ticks = element_blank(), axis.title = element_blank(), axis.text = element_blank())#
ch.communes#
# add the lake and country contours#
lake.df <- formatShp(readOGR(path.ch, layer = "lakes"))#
country.layers <- ogrListLayers(file.path(path.ch, "ch-country.json"))#
country.df <- fortify(readOGR(file.path(path.ch, "ch-country.json"), country.layers[1]))
h.communes + geom_polygon(data = country.df, fill = NA, color = "black", size = 0.1)
ch.communes + geom_polygon(data = country.df, fill = NA, color = "black", size = 0.1)
ogrListLayers(path.ch)
library(swiMap)
system.file("extdata", package="swiMap")
dir(system.file("extdata", package="swiMap"))
dir(system.file("extdata", package="swiMap"), "GDEHist_GDE\\.txt")
?dir
dir(system.file("extdata", package="swiMap"), "GDEHist_GDE\\.txt", full.names = T)
data.path <- dir(system.file("extdata", package="swiMap"), "GDEHist_GDE\\.txt", full.names = T)#
  read.csv(data.path, sep ="\t")
?read.csv
data <- read.csv(data.path, sep ="\t",  header = FALSE)
str(data)
data.path <- dir(system.file("extdata", package="swiMap"), "GDEHist_GDE\\.txt", full.names = T)#
  data <- read.csv(data.path, sep ="\t",  header = FALSE, stringsAsFactors = F)
str(data)
head(data)
colnames(data) <- c('GHSTNR', 'BHSTNR', 'KTKZ', 'GBFSNR', 'GNAME', 'GNAMK', 'GARTE', #
                      'GSTAT', 'GINIMUT', 'GINIART', 'GINIDAT', 'GFINMUT', 'GFINART', #
                      'GFINDAT','GMUTDAT')
str(data)
asDate(data$GINIDAT)
as.Date(data$GINIDAT)
as.date
?as.Date
as.Date(data$GINIDAT, format = "%d.%m.%Y")
str(data)
as.Date(data$GINIDAT, format = "%d.%m.%Y")
data$GINIDAT <- as.Date(data$GINIDAT, format = "%d.%m.%Y")#
  data$GFINDAT <- as.Date(data$GFINDAT, format = "%d.%m.%Y")#
  data$GMUTDAT <- as.Date(data$GMUTDAT, format = "%d.%m.%Y")
str(data)
min(data$GINIDAT)
str(min(data$GINIDAT))
as.Date("1960-01-01")
today()
date()
?date()
Sys.Date()
"2012-01-01"
Sys.Date()
start <- as.Date(start)#
  end <- as.Date(end)
start
start<- "2012-01-01"
end <- Sys.Date()
start <- as.Date(start)#
  end <- as.Date(end)
start
end
str(data)
data$GFINDAT
data$GFINDAT >= start
which(data$GFINDAT >= start)
data[which(data$GFINDAT >= start),]
?encoding
?Encoding
data.path <- dir(system.file("extdata", package="swiMap"), "GDEHist_GDE\\.txt", full.names = T)#
  data <- read.csv(data.path, sep ="\t",  header = FALSE, stringsAsFactors = F, encoding = "latin1")#
  # colnames#
  colnames(data) <- c('GHSTNR', 'BHSTNR', 'KTKZ', 'GBFSNR', 'GNAME', 'GNAMK', 'GARTE', #
                      'GSTAT', 'GINIMUT', 'GINIART', 'GINIDAT', 'GFINMUT', 'GFINART', #
                      'GFINDAT','GMUTDAT')#
  # tranform to dates#
  data$GINIDAT <- as.Date(data$GINIDAT, format = "%d.%m.%Y")#
  data$GFINDAT <- as.Date(data$GFINDAT, format = "%d.%m.%Y")#
  data$GMUTDAT <- as.Date(data$GMUTDAT, format = "%d.%m.%Y")
data[which(data$GFINDAT >= start),]
data[which(data$GFINDAT >= start & data$GINIART == 24),]
data[which(data$GFINDAT >= start & data$GINIART == 26),]
data[which(data$GFINDAT >= start || data$GINIDAT >= start),]
data[which(data$GFINDAT >= start | data$GINIDAT >= start),]
data[which(data$GFINDAT >= start & data$GINIART == 26),]
start
data[which(data$GFINDAT >= start & data$GINIART == 26),'GFINMUT']
data$GFINMUT %in% data[which(data$GFINDAT >= start & data$GINIART == 26),'GINITMUT']
which(data$GFINMUT %in% data[which(data$GFINDAT >= start & data$GINIART == 26),'GINITMUT'])
data[which(data$GFINDAT >= start & data$GINIART == 26),'GFINMUT']
data[which(data$GFINDAT >= start & data$GINIART == 26),]
data[which(data$GFINDAT >= start & data$GINIART == 24),]
which(data$GINIMUT == 3404)
data[which(data$GINIMUT == 3404),]
data[which(data$GFINDAT >= start | data$GINIDAT >= start),]
data[which((data$GFINDAT >= start | data$GINIART >= start) & (data$GFINDAT <= end | data$GINIART <= end)),]
data[which((data$GFINDAT >= start | data$GINIART >= start),]
data[which(data$GFINDAT >= start | data$GINIART >= start),]
data[which(data$GINIMUT == 3404),]
data[which(data$GFINDAT >= start | data$GINIART >= start),]
test<- data[which(data$GFINDAT >= start | data$GINIART >= start),]
data[which(data$GFINDAT >= start | data$GINIART >= start),]
data[which(data$GINIMUT == 3404),]
test
data[which(data$GINIMUT == 3404),]
any(test$GINIMUT == 3404)
summary(data$GFINDAT)
T | NA
NA | T
data[which((data$GFINDAT >= start | data$GINIDAT >= start) & (data$GFINDAT <= end | data$GINIDAT <= end)),]
library(swiTheme)
?multiplot
q1 <- qplot(1:10, 1:10, size = 10:1) + xlab("axis x label") + ylab ("y axis label") + theme_swi2()#
q2 <- qplot(mpg, data = mtcars, geom = "dotplot") + theme_swi()#
multiplot(list(q1, q2))
library(leaflet)
(m <- leaflet() %>% addTiles())
m %>% setView(lng = -1.5, lat = 53.4, zoom = 10) # set centre and extent of map
(m2 <- m %>%#
  setView(-1.5, 53.4, 10) %>% # map location#
  addMarkers(-1.4, 53.5) %>% # add a marker#
  addPopups(-1.6, 53.3, popup = "Hello Sheffield!") %>% # popup#
  # add som circles:#
  addCircles(color = "black", runif(90, -2, -1), runif(90, 53, 54), runif(90, 10, 500)))
library(leaflet)#
m = leaflet() %>% addTiles()
m
? addTiles
library(leaflet)#
m = leaflet() %>% addTiles()
m
m %>% setView(lng = -1.5, lat = 53.4, zoom = 10)
?leaflet
?leafletOutput
(m2 <- m %>%#
  setView(-1.5, 53.4, 10) %>% # map location#
  addMarkers(-1.4, 53.5) %>% # add a marker#
  addPopups(-1.6, 53.3, popup = "Hello Sheffield!") %>% # popup#
  # add som circles:#
  addCircles(color = "black", runif(90, -2, -1), runif(90, 53, 54), runif(90, 10, 500)))
? renderLeaflet
?leafletMap
?leafletOutput
?publish
publish
save
?save
m2
save(m2)
save(m2, "test")
save(m2, file = "test")
getwd()
? html_print
? toHTML
library(streamgraph)#
library(dplyr)#
ggplot2::movies %>%#
  select(year, Action, Animation, Comedy, Drama, Documentary, Romance, Short) %>%#
  tidyr::gather(genre, value, -year) %>%#
  group_by(year, genre) %>%#
  tally(wt=value) %>%#
  streamgraph("genre", "n", "year") %>%#
  sg_axis_x(20) %>%#
  sg_colors("PuOr") %>%#
  sg_legend(show=TRUE, label="Genres: ")
saveWidget
library(rgdal)#
library(leaflet)#
#
tmp <- tempdir()#
#
url <- "http://personal.tcu.edu/kylewalker/data/mexico.zip"#
#
file <- basename(url)#
#
download.file(url, file)#
#
unzip(file, exdir = tmp)#
#
mexico <- readOGR(dsn = tmp, layer = "mexico", encoding = "UTF-8")
library("swiTheme")#
library("swiRcharts")#
library("dplyr")#
library("rjson")#
#
#############################################################################################
###		SETTINGS	#
#############################################################################################
#
votefile <- "data/VOTEScsv_cleaned.csv"#
#
#############################################################################################
###		load initiative data	#
#############################################################################################
#
initiatives.read <- read.csv(votefile, check.names = F, stringsAsFactors = F, encoding = "latin1")#
#
# reverse order #
initiatives.read <- initiatives.read[rev(as.numeric(rownames(initiatives.read))),]#
#
# filter columns#
initiatives <- initiatives.read %>% select(`Date of Votes`, `Title in English`, `Title in German`, `Title in French`, `Title in Italien`, `Yes [%]`, `Theme codes`)#
# transform date to date#
initiatives$date <- as.Date(initiatives$`Date of Votes`)#
#
initiatives$year <- as.numeric(substr(initiatives$`Date of Votes`,1, 4))#
# add counter iniitiative per year #
initiatives <- do.call(rbind, by(initiatives, initiatives$year, function(ii) {#
	cbind(ii, n = nrow(ii):1)#
}))#
#############################################################################################
###		Plot#
#############################################################################################
#
## PLOT SETTINGS#
plot.height <- 350#
#
data <- initiatives %>% select (`Title in English`, `year`, `n`,  `Yes [%]`)#
colnames(data) <- c('name', 'y', 'x', 'value')#
#
a <- Highcharts$new()#
#
# use type='heatmap' for heat maps#
a$chart(zoomType = "x", type = 'heatmap', height = plot.height, plotBackgroundColor = "#f7f5ed", inverted = TRUE)#
a$series( data = rCharts::toJSONArray2(data, json = F, names = T))#
#
a$addParams(colorAxis =#
  list(min = 0, max = 100, stops = list(#
	  list(0, '#ab3d3f'),#
      list(0.499, '#EED8D9'),	  #
      list(0.5, '#999966'),#
      list(1, '#336666') #
  ))#
)#
#
# a$legend(align='right',#
#          layout='vertical',#
#          margin=0,#
#          verticalAlign='top',#
#          y=25,#
#          symbolHeight=plot.height)#
a$yAxis(max = max(data$y), ceiling = max(data$y), maxPadding = 0, tickAmount = 2, gridLineWidth =  0, minorGridLineWidth = 0, title = list(text = ""))#
#
a$xAxis(lineWidth = 0, minorGridLineWidth = 0, lineColor = 'transparent', labels = list(enabled = FALSE), #
	minorTickLength = 0, tickLength =  0)  	#
a$tooltip(formatter = "#! function() { return 'In <b>' + this.point.y + ',</b> the initative:<br><i>' + this.point.name +#
                    '</i><br>recolted <b>' + this.point.value + '%</b> of yes'; } !#")	 #
a$legend(enabled = F)#
a$addAssets(js =#
   c(#"https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js",#
     # "https://code.highcharts.com/highcharts.js",#
     # "https://code.highcharts.com/highcharts-more.js",#
     "https://code.highcharts.com/modules/exporting.js",#
     "https://code.highcharts.com/modules/heatmap.js"#
     )#
)#
a#
#
a$save(destfile = 'initiative.html')#
#
hChart2responsiveHTML("initiative.html", output.html = "initiative_heatmap.html", h2 = "Toutes les initiatives populaires suisses", descr = "",#
	source = "", h3 = "", author = "Duc-Quang Nguyen | swissinfo.ch")
library(swiRchart)
library(swiRcharts)
?hSeries
ibrary(swiTheme)#
a <- rCharts::Highcharts$new()#
x <- 1:10#
y <- seq(1, 100, 10)#
z <- 10:1#
color <- rep(c("grey", "red"), 5)#
name <- c("a", "b", "c", "d", "e", "f", "g", "h", "i", "j")#
series <- c(rep(c("blob", "poop", "doop"), 3), "asdf")#
a$series(hSeries(x,y,z,name, color, series))#
#
# tweak the bubble plot#
a$chart(zoomType = "xy", type = "bubble")#
a$plotOptions(bubble = list(dataLabels = list(enabled = T, style = list(textShadow = 'none') ,#
color = '#aa8959', formatter = "#! function() { return this.point.name; } !#")))#
#
a$colors(swi_rpal)#
a$tooltip(formatter = "#! function() { return this.point.name + ':' +this.x + ', ' + this.y; } !#")#
a$xAxis(title = list(text = "important indicator", align = "high"), lineColor = list ('#FF0000'))#
a#
#
hChart.html <- tempfile("hchart_labelledBubble.html")#
a$save(hChart.html)
library(swiRchart)
library(swiRcharts)
?hSeries
library(swiTheme)#
a <- rCharts::Highcharts$new()#
x <- 1:10#
y <- seq(1, 100, 10)#
z <- 10:1#
color <- rep(c("grey", "red"), 5)#
name <- c("a", "b", "c", "d", "e", "f", "g", "h", "i", "j")#
series <- c(rep(c("blob", "poop", "doop"), 3), "asdf")#
a$series(hSeries(x,y,z,name, color, series))
a$chart(zoomType = "xy", type = "bubble")#
a$plotOptions(bubble = list(dataLabels = list(enabled = T, style = list(textShadow = 'none') ,#
color = '#aa8959', formatter = "#! function() { return this.point.name; } !#")))#
#
a$colors(swi_rpal)#
a$tooltip(formatter = "#! function() { return this.point.name + ':' +this.x + ', ' + this.y; } !#")#
a$xAxis(title = list(text = "important indicator", align = "high"), lineColor = list ('#FF0000'))#
a#
#
hChart.html <- tempfile("hchart_labelledBubble.html")#
a$save(hChart.html)
hChart2responsiveHTML
library(swiRcharts)
?hSeries
library(swiTheme)#
a <- rCharts::Highcharts$new()#
x <- 1:10#
y <- seq(1, 100, 10)#
z <- 10:1#
color <- rep(c("grey", "red"), 5)#
name <- c("a", "b", "c", "d", "e", "f", "g", "h", "i", "j")#
series <- c(rep(c("blob", "poop", "doop"), 3), "asdf")#
a$series(hSeries(x,y,z,name, color, series))
hSeries2 <- hSeries2(data.frame(x = x, y = y, z = z, color = color, name = name, series = series), "series")#
 b <- rCharts::Highcharts$new()#
b$series(hSeries2)
b
install.packages("readr")
install.package("devtools")
install.packages("devtools")
install.packages("rCharts")
install.packages("devtools")#
require(devtools)#
install_github('rCharts', 'ramnathv')#
library(rCharts)
install_github(ramnathv/rCharts)
1:2
rev(1:2)
library(rCharts)
set.seed(123134)#
y <- rnorm(20, 35, 4)#
y[7] <- NA#
y[13] <- NA#
y <- rbind(t(t(y)), t(t(rep(NA, 10))))#
fc <- rnorm(10, 35, 1)#
fc <- rbind(t(t(rep(NA,20))), t(t(fc)))#
uci <- rnorm(10, 38, 1)#
uci <- rbind(t(t(rep(NA,20))), t(t(uci)))#
lci <- rnorm(10, 32, 1)#
lci <- rbind(t(t(rep(NA,20))), t(t(lci)))#
plotData <- data.frame(y,fc,uci,lci)#
#
h1 <- Highcharts$new()#
h1$chart(type="line")#
h1$series(data=plotData$y, marker = list(symbol = 'circle'), connectNulls = TRUE)#
h1$series(data=plotData$fc, marker = list(symbol = 'circle'), connectNulls = TRUE)#
h1$series(data=plotData$uci, showInLegend = FALSE, marker = list(symbol = 'square'), connectNulls = TRUE)#
h1$series(data=plotData$lci, showInLegend = FALSE, marker = list(symbol = 'square'), connectNulls = TRUE)#
h1$series(data=rep(30,30), marker= list(enabled = FALSE))#
h1
257508 / 20524
library(swiMap)
test <- loadCommunesCHportraits()
loadCommunesCHportraits
3700 / 67.2
3.700 / 67.2
6 * 254
6 * 25
install.packages("gridSVG")
setwd('/Users/nguyendu/Google Drive/swissinfo/2015_06_24_euroAsylum')
###### This download the very large monthly data with country of origin!#
library(eurostat)#
library(dplyr)#
library(ggplot2)#
library(swiTheme)#
#
loadData <- F#
inputfile <- "data/02_citizenMonthly_new.Rdata"#
outputfile <- "prod/data/02_citizenMonthly_waffled_new.Rdata"#
#
#############################################################################################
###		Get data#
#############################################################################################
#
if(loadData) {#
	load(file = inputfile)#
} else {#
	##### 1 Get monthly asylum data#
	id <- c('migr_asyappctzm')#
#
	getYearlyData <- function(id) {#
		dat <- get_eurostat(id, time_format = "raw", cache = F )#
		datl <- label_eurostat(dat)#
		# add iso2 code#
		datl$iso2 <- dat$geo#
#
		# transform dates efficiently!#
		times <- unique(datl$time)#
		times <- structure(eurostat:::eurotime2date(times, last = FALSE), names = as.character(times))#
		datl$time <- times[match(datl$time, names(times))]#
		datl#
	}#
	datl1 <- getYearlyData(id[1])#
#
	##### 2 Get Population#
	dat <- get_eurostat('tps00001')#
	datl <- label_eurostat(dat)#
	datl$iso2 <- dat$geo#
#
	pop <- datl %>% filter(time <= as.Date("2015-01-01")) %>% select(one_of(c('geo', 'time','values', 'iso2')))#
	save(datl1, pop, file = inputfile)#
}#
# subset the data for year 2015#
data.m <- datl1 %>% filter(asyl_app == 'Asylum applicant', sex == 'Total', age == 'Total') %>%#
	select(one_of(c('citizen', 'geo', 'time', 'values', 'iso2')))#
# consider only the months with full data (with NA less than 10%) !!#
times <- tapply(data.m$values, data.m$time, function(v) (sum(is.na(v))/length(v)) ) < 0.1#
# subset by time#
data <- data.m %>% filter(time >= as.Date("2015-01-01"), time <= max(as.Date(names(times))[times]))#
	### CHECK ####
## check CH value with http://appsso.eurostat.ec.europa.eu/nui/show.do?dataset=migr_asyappctzm&lang=en#
data %>% filter(iso2 == 'CH', citizen == "Total")#
data %>% filter(iso2 == 'HU', citizen == "Total")#
#
### ANALYSIS#
#
## TO do compare the 2015 monthly statistics with the previous year!#
data.m %>% filter(iso2 == 'CH', citizen == "Total", time < as.Date("2015-01-01"), time >= as.Date("2014-01-01"))#
#############################################################################################
###		WAFFLE chart by origin country of others#
#############################################################################################
#
library(waffle)#
#### Adapt the original function#
waffled <- function (parts, rows = 10, xlab = NULL, title = NULL, colors = NA,#
    size = 2, flip = FALSE, reverse = FALSE, equal = TRUE, pad = 0)#
{#
    part_names <- names(parts)#
    if (length(part_names) < length(parts)) {#
        part_names <- c(part_names, LETTERS[1:length(parts) -#
            length(part_names)])#
    }#
    if (all(is.na(colors))) {#
        colors <- brewer.pal(length(parts), "Set2")#
    }#
    parts_vec <- unlist(sapply(1:length(parts), function(i) {#
        rep(LETTERS[i + 1], parts[i])#
    }))#
    if (reverse) {#
        parts_vec <- rev(parts_vec)#
    }#
    dat <- expand.grid(y = 1:rows, x = seq_len(pad + (ceiling(sum(parts)/rows))))#
	##### My change, added factor and levels being of length parts !!!!!!!!!!!!#
    dat$value <- factor(c(parts_vec, rep(NA, nrow(dat) - length(parts_vec))), levels = LETTERS[2:(length(parts)+1)])#
    if (flip) {#
        gg <- ggplot(dat, aes(x = y, y = x, fill = value))#
    }#
    else {#
        gg <- ggplot(dat, aes(x = x, y = y, fill = value))#
    }#
    gg <- gg + geom_tile(color = "white", size = size)#
    gg <- gg + labs(x = xlab, y = NULL, title = title)#
    gg <- gg + scale_x_continuous(expand = c(0, 0))#
    gg <- gg + scale_y_continuous(expand = c(0, 0))#
    ###### Added this as well, not sure it is useful: drop = FALSE !!!!!!!!!!!!#
	gg <- gg + scale_fill_manual(name = "", values = colors,#
        labels = part_names, drop = FALSE)#
    gg <- gg + guides(fill = guide_legend(override.aes = list(colour = NULL)))#
    if (equal) {#
        gg <- gg + coord_equal()#
    }#
    gg <- gg + theme_bw()#
    gg <- gg + theme(panel.grid = element_blank())#
    gg <- gg + theme(panel.border = element_blank())#
    gg <- gg + theme(panel.background = element_blank())#
    gg <- gg + theme(panel.margin = unit(0, "null"))#
    gg <- gg + theme(axis.text = element_blank())#
    gg <- gg + theme(axis.title.x = element_text(size = 10))#
    gg <- gg + theme(axis.ticks = element_blank())#
    gg <- gg + theme(axis.line = element_blank())#
    gg <- gg + theme(axis.ticks.length = unit(0, "null"))#
    gg <- gg + theme(axis.ticks.margin = unit(0, "null"))#
    gg <- gg + theme(plot.title = element_text(size = 18))#
    gg <- gg + theme(plot.background = element_blank())#
    gg <- gg + theme(plot.margin = unit(c(0, 0, 0, 0), "null"))#
    gg <- gg + theme(plot.margin = rep(unit(0, "null"), 4))#
    gg#
}#
#
###	waffle settings#
font <- "Open Sans"#
unit <- 5 * 10^4#
squareThreshold <- 3#
w.row <- 10#
#
###	COMPUTE#
#
citizenAgg <- c("Total", "European Union (28 countries)", "Extra EU-28")#
#
## Compute the asylum seeker by iso2 country#
dd <- data %>% filter(!citizen %in% citizenAgg, iso2 != "TOTAL") %>% group_by(iso2, geo, citizen) %>% summarise(sum = sum(values, na.rm =T))  %>% ungroup()#
# add population in 2014 column#
dd <- cbind(dd, pop = pop[match(dd$iso2, pop$iso2),'values'])#
# express asylum demand by country per inhabitant * unit#
dd$perU <- (dd$sum / dd$pop) * unit#
dd$sq <- round(dd$perU)#
#
# Check Swiss results#
dd %>% filter(iso2 == 'CH', perU > 0)#
#
### Compute the square/waffle by iso2 and filter it by squareThreshold#
citizen.subset <- as.character(unlist(unique(dd %>% filter(sq > squareThreshold) %>% select(citizen))))#
#
# filter citizen#
dd <- filter(dd, citizen %in% citizen.subset)#
#
# Find the maximum of square (use citizen Total )#
sumAll <- data %>% filter(citizen == "Total", !iso2 %in% c('EU28', 'TOTAL')) %>% group_by(iso2, geo, citizen) %>% summarise(sum = sum(values, na.rm =T)) %>% ungroup()#
# add population in 2014 column#
sumAll <- cbind(sumAll, pop = pop[match(sumAll$iso2, pop$iso2),'values'])#
sumAll$sq <- round((sumAll$sum / sumAll$pop) * unit)#
tmpSum <- as.data.frame(dd %>% group_by(iso2) %>% summarise(tsum = sum(sq, na.rm = T)) %>% ungroup())#
sumAll$others <- sumAll$sq - tmpSum[match(sumAll$iso2, tmpSum$iso2), 2]#
maxCol <- ceiling(max(sumAll$sq) / w.row)#
## Bind others sum to dd#
df <- do.call(rbind, by(dd, dd$iso, function(spt) {#
	iso <- as.character(unique(spt$iso))#
	newrow <- sumAll[sumAll$iso == iso,]#
	colnames(newrow)[colnames(newrow)=='sq'] <- 'perU'#
	colnames(newrow)[colnames(newrow)=='others'] <- 'sq'#
	rbind(spt, newrow)#
}))#
# drop unsused factors#
df$citizen <- factor(df$citizen)#
colorV <- structure(swi_rpal[1:nlevels(df$citizen)], names = levels(df$citizen))#
### SAVE#
save(df, dd, maxCol, data, sumAll, unit, squareThreshold, file = outputfile)#
waffleIso <- function(iso = 'CH') {#
	stopifnot(length(iso) == 1)#
#
	#topText <- paste0("En", )#
	dff <- df %>% filter(iso2 == iso)#
#
	wf <- structure(dff$sq, names = as.character(dff$citizen))#
#
	padding <- maxCol - ceiling(sum(wf) / w.row)#
#
	waffled(wf, rows = w.row, size = 0.7, colors = unname(colorV[match(names(wf), names(colorV))]),#
		pad = padding, xlab = paste("1 carré = demandes d'asile pour ce pays par", unit, "habitant")) +#
		theme(legend.position = "top", legend.key.size = unit(0.7, "line"), legend.key.height = unit(1,"line"),#
		legend.key = element_rect(colour = NA),#
		axis.ticks = element_blank(), axis.text = element_blank()) + ggtitle(iso) +#
		guides(fill = guide_legend(nrow = 2, byrow = TRUE, override.aes = list(colour = NULL)))#
}#
## CHECK CH value with http://appsso.eurostat.ec.europa.eu/nui/show.do?dataset=migr_asyappctzm&lang=en#
	waffleIso('CH')#
	ck <- df %>% filter(iso2 == 'CH')#
	ckdf <- as.data.frame(ck %>% filter(citizen == "Total"))#
	round((ckdf$sum / ckdf$pop) * unit)#
	waffleIso('DE')#
	ck <- df %>% filter(iso2 == 'DE')#
	ckdf <- as.data.frame(ck %>% filter(citizen == "Total"))#
	round((ckdf$sum / ckdf$pop) * unit)#
#
	waffleIso('HU')#
#
	waffleIso('IT')#
	ck <- df %>% filter(iso2 == 'IT')#
	ckdf <- as.data.frame(ck %>% filter(citizen == "Total"))#
	round((ckdf$sum / ckdf$pop) * unit)#
#
	waffleIso('UK')#
	ck <- df %>% filter(iso2 == 'UK')#
	ckdf <- as.data.frame(ck %>% filter(citizen == "Total"))#
	round((ckdf$sum / ckdf$pop) * unit)#
#
	waffleIso('ES')#
	ck <- df %>% filter(iso2 == 'ES')#
	ckdf <- as.data.frame(ck %>% filter(citizen == "Total"))#
	round((ckdf$sum / ckdf$pop) * unit)
str(dd)
dd
setwd('/Users/nguyendu/Google Drive/swissinfo/2015_06_24_euroAsylum')
font <- "Open Sans"#
unit <- 5 * 10^4#
squareThreshold <- 4#
w.row <- 10#
#
###	COMPUTE#
#
citizenAgg <- c("Total", "European Union (28 countries)", "Extra EU-28")#
#
## Compute the asylum seeker by iso2 country#
dd <- data %>% filter(!citizen %in% citizenAgg, iso2 != "TOTAL") %>% group_by(iso2, geo, citizen) %>% summarise(sum = sum(values, na.rm =T))  %>% ungroup()#
# add population in 2014 column#
dd <- cbind(dd, pop = pop[match(dd$iso2, pop$iso2),'values'])#
# express asylum demand by country per inhabitant * unit#
dd$perU <- (dd$sum / dd$pop) * unit#
dd$sq <- round(dd$perU)#
#
# Check Swiss results#
dd %>% filter(iso2 == 'CH', perU > 0)#
#
### Compute the square/waffle by iso2 and filter it by squareThreshold#
citizen.subset <- as.character(unlist(unique(dd %>% filter(sq > squareThreshold) %>% select(citizen))))#
#
# filter citizen#
dd <- filter(dd, citizen %in% citizen.subset)#
#
# Find the maximum of square (use citizen Total )#
sumAll <- data %>% filter(citizen == "Total", !iso2 %in% c('EU28', 'TOTAL')) %>% group_by(iso2, geo, citizen) %>% summarise(sum = sum(values, na.rm =T)) %>% ungroup()#
# add population in 2014 column#
sumAll <- cbind(sumAll, pop = pop[match(sumAll$iso2, pop$iso2),'values'])#
sumAll$sq <- round((sumAll$sum / sumAll$pop) * unit)#
tmpSum <- as.data.frame(dd %>% group_by(iso2) %>% summarise(tsum = sum(sq, na.rm = T)) %>% ungroup())#
sumAll$others <- sumAll$sq - tmpSum[match(sumAll$iso2, tmpSum$iso2), 2]#
maxCol <- ceiling(max(sumAll$sq) / w.row)#
## Bind others sum to dd#
df <- do.call(rbind, by(dd, dd$iso, function(spt) {#
	iso <- as.character(unique(spt$iso))#
	newrow <- sumAll[sumAll$iso == iso,]#
	colnames(newrow)[colnames(newrow)=='sq'] <- 'perU'#
	colnames(newrow)[colnames(newrow)=='others'] <- 'sq'#
	rbind(spt, newrow)#
}))#
# drop unsused factors#
df$citizen <- factor(df$citizen)#
colorV <- structure(swi_rpal[1:nlevels(df$citizen)], names = levels(df$citizen))
setwd('/Users/nguyendu/Google Drive/swissinfo/2015_06_24_euroAsylum')
waffleIso <- function(iso = 'CH') {#
	stopifnot(length(iso) == 1)#
#
	#topText <- paste0("En", )#
	dff <- df %>% filter(iso2 == iso)#
#
	wf <- structure(dff$sq, names = as.character(dff$citizen))#
#
	padding <- maxCol - ceiling(sum(wf) / w.row)#
#
	waffled(wf, rows = w.row, size = 0.7, colors = unname(colorV[match(names(wf), names(colorV))]),#
		pad = padding, xlab = paste("1 carré = demandes d'asile pour ce pays par", unit, "habitant")) +#
		theme(legend.position = "top", legend.key.size = unit(0.7, "line"), legend.key.height = unit(1,"line"),#
		legend.key = element_rect(colour = NA),#
		axis.ticks = element_blank(), axis.text = element_blank()) + ggtitle(iso) +#
		guides(fill = guide_legend(nrow = 2, byrow = TRUE, override.aes = list(colour = NULL)))#
}#
## CHECK CH value with http://appsso.eurostat.ec.europa.eu/nui/show.do?dataset=migr_asyappctzm&lang=en#
	waffleIso('CH')#
	ck <- df %>% filter(iso2 == 'CH')#
	ckdf <- as.data.frame(ck %>% filter(citizen == "Total"))#
	round((ckdf$sum / ckdf$pop) * unit)
setwd('/Users/nguyendu/Google Drive/swissinfo/2015_06_24_euroAsylum')
waffleIso('DE')#
	ck <- df %>% filter(iso2 == 'DE')#
	ckdf <- as.data.frame(ck %>% filter(citizen == "Total"))#
	round((ckdf$sum / ckdf$pop) * unit)
setwd('/Users/nguyendu/Google Drive/swissinfo/2015_06_24_euroAsylum')
waffleIso('HU')
setwd('/Users/nguyendu/Google Drive/swissinfo/2015_06_24_euroAsylum')
waffleIso('CH')
setwd('/Users/nguyendu/Google Drive/swissinfo/2015_06_24_euroAsylum')
ck <- df %>% filter(iso2 == 'CH')#
	ckdf <- as.data.frame(ck %>% filter(citizen == "Total"))#
	round((ckdf$sum / ckdf$pop) * unit)
setwd('/Users/nguyendu/Google Drive/swissinfo/2015_06_24_euroAsylum/prod/scripts')
###### This download the very large monthly data with country of origin!#
#
library(dplyr)#
library(ggplot2)#
library(swiTheme)#
require(gtable)#
library(animation)#
library(png)#
inputData <- "../data/02_citizenMonthly_waffled_new.Rdata"#
load(inputData)#
#
tradFile <- "../trad/02_translation.csv"#
trad <- read.csv(tradFile, check.names = F, stringsAsFactors = F, row.names = 1)#
#
# load SWI logo#
swiLogo <- readPNG("~/swissinfo/_helpers/SWI-RGB.png")
setwd('/Users/nguyendu/Google Drive/swissinfo/2015_06_24_euroAsylum/prod/scripts')
library(waffle)#
#
#### Adapt the original function#
waffled <- function (parts, rows = 10, xlab = NULL, title = NULL, colors = NA,#
    size = 2, flip = FALSE, reverse = FALSE, equal = TRUE, pad = 0)#
{#
    part_names <- names(parts)#
    if (length(part_names) < length(parts)) {#
        part_names <- c(part_names, LETTERS[1:length(parts) -#
            length(part_names)])#
    }#
    if (all(is.na(colors))) {#
        colors <- brewer.pal(length(parts), "Set2")#
    }#
    parts_vec <- unlist(sapply(1:length(parts), function(i) {#
        rep(LETTERS[i + 1], parts[i])#
    }))#
    if (reverse) {#
        parts_vec <- rev(parts_vec)#
    }#
    dat <- expand.grid(y = 1:rows, x = seq_len(pad + (ceiling(sum(parts)/rows))))#
	##### My change 1 , added factor and levels being of length "parts" (even if some parts have 0 square) !!!!!!!!!!!!#
    dat$value <- factor(c(parts_vec, rep(NA, nrow(dat) - length(parts_vec))), levels = LETTERS[2:(length(parts)+1)])#
    ##### Changes 2, do not pass data in ggplot but to geom_tile#
	if (flip) {#
		gg <- ggplot() + geom_tile(data = dat, aes(x = y, y = x, fill = value), color = "white", size = size)#
    }#
    else {#
		gg <- ggplot() + geom_tile(data = dat, aes(x = x, y = y, fill = value), color = "white", size = size)#
    }#
    #gg <- gg + geom_tile(color = "white", size = size)#
    gg <- gg + labs(x = xlab, y = NULL, title = title)#
    gg <- gg + scale_x_continuous(expand = c(0, 0))#
    gg <- gg + scale_y_continuous(expand = c(0, 0))#
    ###### 3 Added this as well, not sure it is useful: drop = FALSE !!!!!!!!!!!!#
	gg <- gg + scale_fill_manual(name = "", values = colors,#
        labels = part_names, drop = FALSE)#
    gg <- gg + guides(fill = guide_legend(override.aes = list(colour = NULL)))#
    if (equal) {#
        gg <- gg + coord_equal()#
    }#
    gg <- gg + theme_bw()#
    gg <- gg + theme(panel.grid = element_blank())#
    gg <- gg + theme(panel.border = element_blank())#
    gg <- gg + theme(panel.background = element_blank())#
    gg <- gg + theme(panel.margin = unit(0, "null"))#
    gg <- gg + theme(axis.text = element_blank())#
    gg <- gg + theme(axis.title.x = element_text(size = 10))#
    gg <- gg + theme(axis.ticks = element_blank())#
    gg <- gg + theme(axis.line = element_blank())#
    gg <- gg + theme(axis.ticks.length = unit(0, "null"))#
    gg <- gg + theme(axis.ticks.margin = unit(0, "null"))#
    gg <- gg + theme(plot.title = element_text(size = 18))#
    gg <- gg + theme(plot.background = element_blank())#
	## Change 4 make space on the top and comment the other line#
    gg <- gg + theme(plot.margin = unit(c(2.8, 0, 0.5, 0), "lines"))#
    # gg <- gg + theme(plot.margin = rep(unit(0, "null"), 4))#
    gg#
}#
#############################################################################################
### subset the whole dataset and save the production data.frame#
#############################################################################################
#
range(data$time)#
tmp <- as.data.frame(df %>% filter(iso2 != 'EU28') %>% group_by(iso2) %>%#
	summarise(totsq = sum(sq)) %>% filter(totsq > 2 | iso2 %in% c('PT', 'ES')) %>%#
	filter(!iso2 %in% c('LI', 'IS', 'CZ', 'HR', 'LT', 'LV', 'SI', 'SK', 'BG', 'EE', 'LU', 'PT', 'BE', 'FI', 'IE', 'NO', 'NL', 'DK')))#
#
iso.ordered <- as.character(tmp$iso2[order(tmp$totsq)])#
#
## Create the translation data.frame#
t.df <- df %>% filter(iso2 %in% iso.ordered) %>% select(iso2, geo, citizen)#
#
t.df <- rbind(unique(t.df[,1:2]), data.frame(iso2 = paste0("cit.", substr(unique(t.df$citizen), 1, 4)), geo = unique(t.df$citizen)))#
colnames(t.df) <- c('code', 'en')
setwd('/Users/nguyendu/Google Drive/swissinfo/2015_06_24_euroAsylum/prod/scripts')
t.df
setwd('/Users/nguyendu/Google Drive/swissinfo/2015_06_24_euroAsylum')
font <- "Open Sans"#
unit <- 5 * 10^4#
squareThreshold <- 5#
w.row <- 10#
#
###	COMPUTE#
#
citizenAgg <- c("Total", "European Union (28 countries)", "Extra EU-28")#
#
## Compute the asylum seeker by iso2 country#
dd <- data %>% filter(!citizen %in% citizenAgg, iso2 != "TOTAL") %>% group_by(iso2, geo, citizen) %>% summarise(sum = sum(values, na.rm =T))  %>% ungroup()#
# add population in 2014 column#
dd <- cbind(dd, pop = pop[match(dd$iso2, pop$iso2),'values'])#
# express asylum demand by country per inhabitant * unit#
dd$perU <- (dd$sum / dd$pop) * unit#
dd$sq <- round(dd$perU)#
#
# Check Swiss results#
dd %>% filter(iso2 == 'CH', perU > 0)#
#
### Compute the square/waffle by iso2 and filter it by squareThreshold#
citizen.subset <- as.character(unlist(unique(dd %>% filter(sq > squareThreshold) %>% select(citizen))))#
#
# filter citizen#
dd <- filter(dd, citizen %in% citizen.subset)#
#
# Find the maximum of square (use citizen Total )#
sumAll <- data %>% filter(citizen == "Total", !iso2 %in% c('EU28', 'TOTAL')) %>% group_by(iso2, geo, citizen) %>% summarise(sum = sum(values, na.rm =T)) %>% ungroup()#
# add population in 2014 column#
sumAll <- cbind(sumAll, pop = pop[match(sumAll$iso2, pop$iso2),'values'])#
sumAll$sq <- round((sumAll$sum / sumAll$pop) * unit)#
tmpSum <- as.data.frame(dd %>% group_by(iso2) %>% summarise(tsum = sum(sq, na.rm = T)) %>% ungroup())#
sumAll$others <- sumAll$sq - tmpSum[match(sumAll$iso2, tmpSum$iso2), 2]#
maxCol <- ceiling(max(sumAll$sq) / w.row)#
## Bind others sum to dd#
df <- do.call(rbind, by(dd, dd$iso, function(spt) {#
	iso <- as.character(unique(spt$iso))#
	newrow <- sumAll[sumAll$iso == iso,]#
	colnames(newrow)[colnames(newrow)=='sq'] <- 'perU'#
	colnames(newrow)[colnames(newrow)=='others'] <- 'sq'#
	rbind(spt, newrow)#
}))#
# drop unsused factors#
df$citizen <- factor(df$citizen)#
colorV <- structure(swi_rpal[1:nlevels(df$citizen)], names = levels(df$citizen))#
### SAVE#
save(df, dd, maxCol, data, sumAll, unit, squareThreshold, file = outputfile)#
waffleIso <- function(iso = 'CH') {#
	stopifnot(length(iso) == 1)#
#
	#topText <- paste0("En", )#
	dff <- df %>% filter(iso2 == iso)#
#
	wf <- structure(dff$sq, names = as.character(dff$citizen))#
#
	padding <- maxCol - ceiling(sum(wf) / w.row)#
#
	waffled(wf, rows = w.row, size = 0.7, colors = unname(colorV[match(names(wf), names(colorV))]),#
		pad = padding, xlab = paste("1 carré = demandes d'asile pour ce pays par", unit, "habitant")) +#
		theme(legend.position = "top", legend.key.size = unit(0.7, "line"), legend.key.height = unit(1,"line"),#
		legend.key = element_rect(colour = NA),#
		axis.ticks = element_blank(), axis.text = element_blank()) + ggtitle(iso) +#
		guides(fill = guide_legend(nrow = 2, byrow = TRUE, override.aes = list(colour = NULL)))#
}#
## CHECK CH value with http://appsso.eurostat.ec.europa.eu/nui/show.do?dataset=migr_asyappctzm&lang=en#
	waffleIso('CH')#
	ck <- df %>% filter(iso2 == 'CH')#
	ckdf <- as.data.frame(ck %>% filter(citizen == "Total"))#
	round((ckdf$sum / ckdf$pop) * unit)
setwd('/Users/nguyendu/Google Drive/swissinfo/2015_06_24_euroAsylum')
font <- "Open Sans"#
unit <- 5 * 10^4#
squareThreshold <- 6#
w.row <- 10#
#
###	COMPUTE#
#
citizenAgg <- c("Total", "European Union (28 countries)", "Extra EU-28")#
#
## Compute the asylum seeker by iso2 country#
dd <- data %>% filter(!citizen %in% citizenAgg, iso2 != "TOTAL") %>% group_by(iso2, geo, citizen) %>% summarise(sum = sum(values, na.rm =T))  %>% ungroup()#
# add population in 2014 column#
dd <- cbind(dd, pop = pop[match(dd$iso2, pop$iso2),'values'])#
# express asylum demand by country per inhabitant * unit#
dd$perU <- (dd$sum / dd$pop) * unit#
dd$sq <- round(dd$perU)#
#
# Check Swiss results#
dd %>% filter(iso2 == 'CH', perU > 0)#
#
### Compute the square/waffle by iso2 and filter it by squareThreshold#
citizen.subset <- as.character(unlist(unique(dd %>% filter(sq > squareThreshold) %>% select(citizen))))#
#
# filter citizen#
dd <- filter(dd, citizen %in% citizen.subset)#
#
# Find the maximum of square (use citizen Total )#
sumAll <- data %>% filter(citizen == "Total", !iso2 %in% c('EU28', 'TOTAL')) %>% group_by(iso2, geo, citizen) %>% summarise(sum = sum(values, na.rm =T)) %>% ungroup()#
# add population in 2014 column#
sumAll <- cbind(sumAll, pop = pop[match(sumAll$iso2, pop$iso2),'values'])#
sumAll$sq <- round((sumAll$sum / sumAll$pop) * unit)#
tmpSum <- as.data.frame(dd %>% group_by(iso2) %>% summarise(tsum = sum(sq, na.rm = T)) %>% ungroup())#
sumAll$others <- sumAll$sq - tmpSum[match(sumAll$iso2, tmpSum$iso2), 2]#
maxCol <- ceiling(max(sumAll$sq) / w.row)#
## Bind others sum to dd#
df <- do.call(rbind, by(dd, dd$iso, function(spt) {#
	iso <- as.character(unique(spt$iso))#
	newrow <- sumAll[sumAll$iso == iso,]#
	colnames(newrow)[colnames(newrow)=='sq'] <- 'perU'#
	colnames(newrow)[colnames(newrow)=='others'] <- 'sq'#
	rbind(spt, newrow)#
}))#
# drop unsused factors#
df$citizen <- factor(df$citizen)#
colorV <- structure(swi_rpal[1:nlevels(df$citizen)], names = levels(df$citizen))#
### SAVE#
save(df, dd, maxCol, data, sumAll, unit, squareThreshold, file = outputfile)#
waffleIso <- function(iso = 'CH') {#
	stopifnot(length(iso) == 1)#
#
	#topText <- paste0("En", )#
	dff <- df %>% filter(iso2 == iso)#
#
	wf <- structure(dff$sq, names = as.character(dff$citizen))#
#
	padding <- maxCol - ceiling(sum(wf) / w.row)#
#
	waffled(wf, rows = w.row, size = 0.7, colors = unname(colorV[match(names(wf), names(colorV))]),#
		pad = padding, xlab = paste("1 carré = demandes d'asile pour ce pays par", unit, "habitant")) +#
		theme(legend.position = "top", legend.key.size = unit(0.7, "line"), legend.key.height = unit(1,"line"),#
		legend.key = element_rect(colour = NA),#
		axis.ticks = element_blank(), axis.text = element_blank()) + ggtitle(iso) +#
		guides(fill = guide_legend(nrow = 2, byrow = TRUE, override.aes = list(colour = NULL)))#
}#
## CHECK CH value with http://appsso.eurostat.ec.europa.eu/nui/show.do?dataset=migr_asyappctzm&lang=en#
	waffleIso('CH')#
	ck <- df %>% filter(iso2 == 'CH')#
	ckdf <- as.data.frame(ck %>% filter(citizen == "Total"))#
	round((ckdf$sum / ckdf$pop) * unit)
setwd('/Users/nguyendu/Google Drive/swissinfo/2015_06_24_euroAsylum')
dd$sq
dd
unique(dd %>% filter(sq > squareThreshold) %>% select(citizen))
setwd('/Users/nguyendu/Google Drive/swissinfo/2015_06_24_euroAsylum')
dd %>% group_by(citizen) %>% summarise(perU.sum = sum(perU))
?arrange
dd %>% group_by(citizen) %>% summarise(perU.sum = sum(perU)) %>% arrange(desc(perU.sum))
setwd('/Users/nguyendu/Google Drive/swissinfo/2015_06_24_euroAsylum')
dd %>% filter(iso2 == 'CH', perU > 0)
data.frame(dd %>% filter(iso2 == 'CH', perU > 0))
data.frame(dd %>% filter(iso2 == 'CH', perU > 0))$sum
sum(data.frame(dd %>% filter(iso2 == 'CH', perU > 0))$sum)
setwd('/Users/nguyendu/Google Drive/swissinfo/2015_06_24_euroAsylum')
times
data %>% filter(iso2 == 'CH')
sum(data.frame(dd %>% filter(iso2 == 'CH', perU > 0))$sum)
setwd('/Users/nguyendu/Google Drive/swissinfo/2015_06_24_euroAsylum')
sum(data.frame(dd %>% filter(iso2 == 'CH', perU > 0))$sum)
data %>% filter(iso2 == 'CH', citizen == 'Total')
dd %>% filter(iso2 == 'CH', perU > 0
)
dd %>% filter(iso2 == 'CH')
setwd('/Users/nguyendu/Google Drive/swissinfo/2015_06_24_euroAsylum')
dd %>% filter(iso2 == 'CH')
setwd('/Users/nguyendu/Google Drive/swissinfo/2015_06_24_euroAsylum')
data %>% filter(iso2 == 'CH')
setwd('/Users/nguyendu/Google Drive/swissinfo/2015_06_24_euroAsylum')
data %>% filter(iso2 == 'CH', !citizen %in% citizenAgg, iso2 != "TOTAL")
setwd('/Users/nguyendu/Google Drive/swissinfo/2015_06_24_euroAsylum')
data %>% filter(iso2 == 'CH', !citizen %in% citizenAgg, iso2 != "TOTAL") %>% group_by(time) %>% summarise(testSum = sum(values, na.rm = T))
setwd('/Users/nguyendu/Google Drive/swissinfo/2015_06_24_euroAsylum')
data %>% filter(iso2 == 'CH', !citizen %in% citizenAgg, iso2 != "TOTAL") %>% group_by(time) %>% summarise(testSum = sum(values, na.rm = T)) %>% ungroup()
setwd('/Users/nguyendu/Google Drive/swissinfo/2015_06_24_euroAsylum')
data %>% filter(iso2 == 'CH', citizen == 'Total')
setwd('/Users/nguyendu/Google Drive/swissinfo/2015_06_24_euroAsylum')
citizen.subset <- as.character(unlist(unique(dd %>% filter(sq > squareThreshold) %>% select(citizen))))
citizen.subset
setwd('/Users/nguyendu/Google Drive/swissinfo/2015_06_24_euroAsylum')
dd %>% group_by(citizen) %>% summarise(perU.sum = sum(perU))
setwd('/Users/nguyendu/Google Drive/swissinfo/2015_06_24_euroAsylum')
dd %>% group_by(citizen) %>% summarise(perU.sum = sum(perU)) %>% arrange(desc(perU.sum))
data.frame(dd %>% group_by(citizen) %>% summarise(perU.sum = sum(perU)) %>% arrange(desc(perU.sum)))$citizen
setwd('/Users/nguyendu/Google Drive/swissinfo/2015_06_24_euroAsylum')
citizen.subset <- head(data.frame(dd %>% group_by(citizen) %>% summarise(perU.sum = sum(perU)) %>% arrange(desc(perU.sum)))$citizen, topCitNat)
setwd('/Users/nguyendu/Google Drive/swissinfo/2015_06_24_euroAsylum')
topCitNat <- 12
setwd('/Users/nguyendu/Google Drive/swissinfo/2015_06_24_euroAsylum')
citizen.subset <- head(data.frame(dd %>% group_by(citizen) %>% summarise(perU.sum = sum(perU)) %>% arrange(desc(perU.sum)))$citizen, topCitNat)
citizen.subset
setwd('/Users/nguyendu/Google Drive/swissinfo/2015_06_24_euroAsylum')
as.character(unlist(unique(dd %>% filter(sq > squareThreshold) %>% select(citizen))))
setwd('/Users/nguyendu/Google Drive/swissinfo/2015_06_24_euroAsylum')
citizen.subset <- as.character(head(data.frame(dd %>% group_by(citizen) %>% summarise(perU.sum = sum(perU)) %>% #
	arrange(desc(perU.sum)))$citizen, topCitNat))
citizen.subset
setwd('/Users/nguyendu/Google Drive/swissinfo/2015_06_24_euroAsylum')
# filter citizen#
dd <- filter(dd, citizen %in% citizen.subset)#
#
# Find the maximum of square (use citizen Total )#
sumAll <- data %>% filter(citizen == "Total", !iso2 %in% c('EU28', 'TOTAL')) %>% group_by(iso2, geo, citizen) %>% summarise(sum = sum(values, na.rm =T)) %>% ungroup()#
# add population in 2014 column#
sumAll <- cbind(sumAll, pop = pop[match(sumAll$iso2, pop$iso2),'values'])#
sumAll$sq <- round((sumAll$sum / sumAll$pop) * unit)#
tmpSum <- as.data.frame(dd %>% group_by(iso2) %>% summarise(tsum = sum(sq, na.rm = T)) %>% ungroup())#
sumAll$others <- sumAll$sq - tmpSum[match(sumAll$iso2, tmpSum$iso2), 2]#
maxCol <- ceiling(max(sumAll$sq) / w.row)#
## Bind others sum to dd#
df <- do.call(rbind, by(dd, dd$iso, function(spt) {#
	iso <- as.character(unique(spt$iso))#
	newrow <- sumAll[sumAll$iso == iso,]#
	colnames(newrow)[colnames(newrow)=='sq'] <- 'perU'#
	colnames(newrow)[colnames(newrow)=='others'] <- 'sq'#
	rbind(spt, newrow)#
}))#
# drop unsused factors#
df$citizen <- factor(df$citizen)#
colorV <- structure(swi_rpal[1:nlevels(df$citizen)], names = levels(df$citizen))#
### SAVE#
save(df, dd, maxCol, data, sumAll, unit, squareThreshold, file = outputfile)#
waffleIso <- function(iso = 'CH') {#
	stopifnot(length(iso) == 1)#
#
	#topText <- paste0("En", )#
	dff <- df %>% filter(iso2 == iso)#
#
	wf <- structure(dff$sq, names = as.character(dff$citizen))#
#
	padding <- maxCol - ceiling(sum(wf) / w.row)#
#
	waffled(wf, rows = w.row, size = 0.7, colors = unname(colorV[match(names(wf), names(colorV))]),#
		pad = padding, xlab = paste("1 carré = demandes d'asile pour ce pays par", unit, "habitant")) +#
		theme(legend.position = "top", legend.key.size = unit(0.7, "line"), legend.key.height = unit(1,"line"),#
		legend.key = element_rect(colour = NA),#
		axis.ticks = element_blank(), axis.text = element_blank()) + ggtitle(iso) +#
		guides(fill = guide_legend(nrow = 2, byrow = TRUE, override.aes = list(colour = NULL)))#
}#
## CHECK CH value with http://appsso.eurostat.ec.europa.eu/nui/show.do?dataset=migr_asyappctzm&lang=en#
	waffleIso('CH')#
	ck <- df %>% filter(iso2 == 'CH')#
	ckdf <- as.data.frame(ck %>% filter(citizen == "Total"))#
	round((ckdf$sum / ckdf$pop) * unit)
setwd('/Users/nguyendu/Google Drive/swissinfo/2015_06_24_euroAsylum')
waffleIso('HU')
setwd('/Users/nguyendu/Google Drive/swissinfo/2015_06_24_euroAsylum')
waffleIso('ES')#
	ck <- df %>% filter(iso2 == 'ES')#
	ckdf <- as.data.frame(ck %>% filter(citizen == "Total"))#
	round((ckdf$sum / ckdf$pop) * unit)
setwd('/Users/nguyendu/Google Drive/swissinfo/2015_06_24_euroAsylum')
# subset the data for year 2015#
data.m <- datl1 %>% filter(asyl_app == 'Asylum applicant', sex == 'Total', age == 'Total') %>%#
	select(one_of(c('citizen', 'geo', 'time', 'values', 'iso2')))#
# consider only the months with full data (with NA less than 10%) !!#
times <- tapply(data.m$values, data.m$time, function(v) (sum(is.na(v))/length(v)) ) < 0.1#
# subset by time#
data <- data.m %>% filter(time >= as.Date("2015-01-01"), time <= max(as.Date(names(times))[times]))#
	### CHECK ####
## check CH value with http://appsso.eurostat.ec.europa.eu/nui/show.do?dataset=migr_asyappctzm&lang=en#
data %>% filter(iso2 == 'CH', citizen == "Total")#
data %>% filter(iso2 == 'HU', citizen == "Total")#
#
### ANALYSIS#
#
## TO do compare the 2015 monthly statistics with the previous year!#
data.m %>% filter(iso2 == 'CH', citizen == "Total", time < as.Date("2015-01-01"), time >= as.Date("2014-01-01"))#
#############################################################################################
###		WAFFLE chart by origin country of others#
#############################################################################################
#
library(waffle)#
#### Adapt the original function#
waffled <- function (parts, rows = 10, xlab = NULL, title = NULL, colors = NA,#
    size = 2, flip = FALSE, reverse = FALSE, equal = TRUE, pad = 0)#
{#
    part_names <- names(parts)#
    if (length(part_names) < length(parts)) {#
        part_names <- c(part_names, LETTERS[1:length(parts) -#
            length(part_names)])#
    }#
    if (all(is.na(colors))) {#
        colors <- brewer.pal(length(parts), "Set2")#
    }#
    parts_vec <- unlist(sapply(1:length(parts), function(i) {#
        rep(LETTERS[i + 1], parts[i])#
    }))#
    if (reverse) {#
        parts_vec <- rev(parts_vec)#
    }#
    dat <- expand.grid(y = 1:rows, x = seq_len(pad + (ceiling(sum(parts)/rows))))#
	##### My change, added factor and levels being of length parts !!!!!!!!!!!!#
    dat$value <- factor(c(parts_vec, rep(NA, nrow(dat) - length(parts_vec))), levels = LETTERS[2:(length(parts)+1)])#
    if (flip) {#
        gg <- ggplot(dat, aes(x = y, y = x, fill = value))#
    }#
    else {#
        gg <- ggplot(dat, aes(x = x, y = y, fill = value))#
    }#
    gg <- gg + geom_tile(color = "white", size = size)#
    gg <- gg + labs(x = xlab, y = NULL, title = title)#
    gg <- gg + scale_x_continuous(expand = c(0, 0))#
    gg <- gg + scale_y_continuous(expand = c(0, 0))#
    ###### Added this as well, not sure it is useful: drop = FALSE !!!!!!!!!!!!#
	gg <- gg + scale_fill_manual(name = "", values = colors,#
        labels = part_names, drop = FALSE)#
    gg <- gg + guides(fill = guide_legend(override.aes = list(colour = NULL)))#
    if (equal) {#
        gg <- gg + coord_equal()#
    }#
    gg <- gg + theme_bw()#
    gg <- gg + theme(panel.grid = element_blank())#
    gg <- gg + theme(panel.border = element_blank())#
    gg <- gg + theme(panel.background = element_blank())#
    gg <- gg + theme(panel.margin = unit(0, "null"))#
    gg <- gg + theme(axis.text = element_blank())#
    gg <- gg + theme(axis.title.x = element_text(size = 10))#
    gg <- gg + theme(axis.ticks = element_blank())#
    gg <- gg + theme(axis.line = element_blank())#
    gg <- gg + theme(axis.ticks.length = unit(0, "null"))#
    gg <- gg + theme(axis.ticks.margin = unit(0, "null"))#
    gg <- gg + theme(plot.title = element_text(size = 18))#
    gg <- gg + theme(plot.background = element_blank())#
    gg <- gg + theme(plot.margin = unit(c(0, 0, 0, 0), "null"))#
    gg <- gg + theme(plot.margin = rep(unit(0, "null"), 4))#
    gg#
}#
#
###	waffle settings#
font <- "Open Sans"#
unit <- 5 * 10^4#
squareThreshold <- 4 ## deprecated !! #
topCitNat <- 12#
w.row <- 10#
#
###	COMPUTE#
#
citizenAgg <- c("Total", "European Union (28 countries)", "Extra EU-28")#
#
## Compute the asylum seeker by iso2 country#
dd <- data %>% filter(!citizen %in% citizenAgg, iso2 != "TOTAL") %>% group_by(iso2, geo, citizen) %>% summarise(sum = sum(values, na.rm =T))  %>% ungroup()#
# add population in 2014 column#
dd <- cbind(dd, pop = pop[match(dd$iso2, pop$iso2),'values'])#
# express asylum demand by country per inhabitant * unit#
dd$perU <- (dd$sum / dd$pop) * unit#
dd$sq <- round(dd$perU)#
#
# Check Swiss results ##
dd %>% filter(iso2 == 'CH', perU > 0)#
data %>% filter(iso2 == 'CH', citizen == 'Total')#
data %>% filter(iso2 == 'CH', !citizen %in% citizenAgg, iso2 != "TOTAL") %>% group_by(time) %>% summarise(testSum = sum(values, na.rm = T)) %>% ungroup()#
### Compute the square/waffle by iso2 and filter it by squareThreshold#
# old way to filter the citizen to display: get all country of origin with more than 5 squares#
citizen.subset <- as.character(unlist(unique(dd %>% filter(sq > squareThreshold) %>% select(citizen))))#
citizen.subset <- as.character(head(data.frame(dd %>% group_by(citizen) %>% summarise(perU.sum = sum(perU)) %>% #
	arrange(desc(perU.sum)))$citizen, topCitNat))#
# filter citizen#
dd <- filter(dd, citizen %in% citizen.subset)#
#
# Find the maximum of square (use citizen Total )#
sumAll <- data %>% filter(citizen == "Total", !iso2 %in% c('EU28', 'TOTAL')) %>% group_by(iso2, geo, citizen) %>% summarise(sum = sum(values, na.rm =T)) %>% ungroup()#
# add population in 2014 column#
sumAll <- cbind(sumAll, pop = pop[match(sumAll$iso2, pop$iso2),'values'])#
sumAll$sq <- round((sumAll$sum / sumAll$pop) * unit)#
tmpSum <- as.data.frame(dd %>% group_by(iso2) %>% summarise(tsum = sum(sq, na.rm = T)) %>% ungroup())#
sumAll$others <- sumAll$sq - tmpSum[match(sumAll$iso2, tmpSum$iso2), 2]#
maxCol <- ceiling(max(sumAll$sq) / w.row)#
## Bind others sum to dd#
df <- do.call(rbind, by(dd, dd$iso, function(spt) {#
	iso <- as.character(unique(spt$iso))#
	newrow <- sumAll[sumAll$iso == iso,]#
	colnames(newrow)[colnames(newrow)=='sq'] <- 'perU'#
	colnames(newrow)[colnames(newrow)=='others'] <- 'sq'#
	rbind(spt, newrow)#
}))#
# drop unsused factors#
df$citizen <- factor(df$citizen)#
colorV <- structure(swi_rpal[1:nlevels(df$citizen)], names = levels(df$citizen))#
### SAVE#
save(df, dd, maxCol, data, sumAll, unit, squareThreshold, file = outputfile)
